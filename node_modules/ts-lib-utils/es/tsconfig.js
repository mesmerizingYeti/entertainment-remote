import { __assign, __awaiter, __generator, __read, __spread, __values } from "tslib";
import ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';
import glob from 'glob';
/**
 * @public
 */
export function getProjectRootNamesAndCompilerOptions(project) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, configFilePath, dirname, config, _b, compilerOptions, errors, rootNames;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = getTsConfigFilePath(project), configFilePath = _a.configFilePath, dirname = _a.dirname;
                    return [4 /*yield*/, getTsConfig(configFilePath, dirname)];
                case 1:
                    config = _c.sent();
                    _b = ts.convertCompilerOptionsFromJson(config.compilerOptions, config.basePath || dirname), compilerOptions = _b.options, errors = _b.errors;
                    if (errors && errors.length > 0) {
                        throw errors;
                    }
                    return [4 /*yield*/, getRootNames(config, dirname)];
                case 2:
                    rootNames = _c.sent();
                    return [2 /*return*/, { rootNames: rootNames, compilerOptions: compilerOptions }];
            }
        });
    });
}
function getTsConfigFilePath(project, fallbackProject) {
    var configFilePath;
    var dirname;
    var projectStats;
    try {
        projectStats = fs.statSync(project);
    }
    catch (error) {
        if (fallbackProject) {
            while (fallbackProject.length > 0) {
                try {
                    project = fallbackProject[0];
                    projectStats = fs.statSync(project);
                    break;
                }
                catch (_a) {
                    fallbackProject.shift();
                }
            }
        }
        else {
            throw error;
        }
    }
    if (!projectStats) {
        try {
            projectStats = fs.statSync(project + '.json');
            if (projectStats) {
                project = project + '.json';
            }
        }
        catch (_b) {
            // do nothing
        }
    }
    if (projectStats && projectStats.isDirectory()) {
        configFilePath = path.resolve(project, 'tsconfig.json');
        dirname = project;
    }
    else if (projectStats && projectStats.isFile()) {
        configFilePath = project;
        dirname = path.dirname(project);
    }
    else {
        throw new Error("paramter 'project' should be a file or directory.");
    }
    return { configFilePath: configFilePath, dirname: dirname };
}
function getTsConfig(configFilePath, dirname) {
    return __awaiter(this, void 0, void 0, function () {
        var configResult, config, project, fallbackProjects, paths, _a, configFilePath_1, extendsBasename, extendsConfig, topLevelBaseUrl;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    configResult = ts.readConfigFile(configFilePath, function (p) { return fs.readFileSync(p).toString(); });
                    config = configResult.error ? {
                        extends: undefined,
                        compilerOptions: {
                            lib: [
                                'dom',
                                'es5',
                                'es2015',
                                'es2016',
                                'es2017'
                            ],
                            allowSyntheticDefaultImports: true
                        }
                    } : configResult.config;
                    if (!config.extends) return [3 /*break*/, 6];
                    project = void 0;
                    fallbackProjects = [];
                    if (!path.isAbsolute(config.extends)) return [3 /*break*/, 1];
                    project = config.extends;
                    return [3 /*break*/, 4];
                case 1:
                    if (!(config.extends === '.'
                        || config.extends === '..'
                        || config.extends.startsWith("." + path.sep)
                        || config.extends.startsWith(".." + path.sep)
                        || config.extends.startsWith('./')
                        || config.extends.startsWith('../'))) return [3 /*break*/, 2];
                    project = path.resolve(dirname, config.extends);
                    return [3 /*break*/, 4];
                case 2:
                    project = path.resolve(dirname, 'node_modules', config.extends);
                    return [4 /*yield*/, findParentsWithNodeModules(dirname)];
                case 3:
                    paths = _b.sent();
                    fallbackProjects = paths.map(function (p) { return path.resolve(p, 'node_modules', config.extends || ''); });
                    _b.label = 4;
                case 4:
                    _a = getTsConfigFilePath(project, fallbackProjects), configFilePath_1 = _a.configFilePath, extendsBasename = _a.dirname;
                    return [4 /*yield*/, getTsConfig(configFilePath_1, extendsBasename)];
                case 5:
                    extendsConfig = _b.sent();
                    topLevelBaseUrl = config.compilerOptions ? config.compilerOptions.baseUrl : undefined;
                    config.compilerOptions = __assign(__assign({}, extendsConfig.compilerOptions), config.compilerOptions);
                    config.basePath = topLevelBaseUrl ? dirname : extendsBasename;
                    _b.label = 6;
                case 6: return [2 /*return*/, config];
            }
        });
    });
}
function getRootNames(config, dirname) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function () {
        var include, exclude, files, rules, include_1, include_1_1, file, currentPath, stats, e_1_1, includeFiles, rootNames;
        var e_1, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    include = config.include;
                    exclude = config.exclude || ['node_modules/**'];
                    files = (_b = (_a = config.files) === null || _a === void 0 ? void 0 : _a.map(function (f) { return path.resolve(dirname, f); })) !== null && _b !== void 0 ? _b : [];
                    if (!(include && Array.isArray(include) && include.length > 0)) return [3 /*break*/, 10];
                    rules = [];
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 6, 7, 8]);
                    include_1 = __values(include), include_1_1 = include_1.next();
                    _d.label = 2;
                case 2:
                    if (!!include_1_1.done) return [3 /*break*/, 5];
                    file = include_1_1.value;
                    currentPath = path.resolve(dirname, file);
                    return [4 /*yield*/, statAsync(currentPath)];
                case 3:
                    stats = _d.sent();
                    if (stats === undefined) {
                        rules.push(currentPath);
                    }
                    else if (stats.isDirectory()) {
                        rules.push((currentPath.endsWith('/') ? currentPath.substring(0, currentPath.length - 1) : currentPath) + "/**/*.{ts,tsx}");
                    }
                    else if (stats.isFile()) {
                        rules.push(currentPath);
                    }
                    _d.label = 4;
                case 4:
                    include_1_1 = include_1.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (include_1_1 && !include_1_1.done && (_c = include_1.return)) _c.call(include_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [4 /*yield*/, globAsync(rules.length === 1 ? rules[0] : "{" + rules.join(',') + "}", exclude, dirname)];
                case 9:
                    includeFiles = _d.sent();
                    return [2 /*return*/, __spread(files, includeFiles)];
                case 10:
                    if (config.files) {
                        return [2 /*return*/, files];
                    }
                    return [4 /*yield*/, globAsync("**/*.{ts,tsx}", exclude, dirname)];
                case 11:
                    rootNames = _d.sent();
                    return [2 /*return*/, rootNames.map(function (r) { return path.resolve(process.cwd(), dirname, r); })];
            }
        });
    });
}
function statAsync(file) {
    return new Promise(function (resolve) {
        fs.stat(file, function (error, stats) {
            if (error) {
                resolve(undefined);
            }
            else {
                resolve(stats);
            }
        });
    });
}
function globAsync(pattern, ignore, cwd) {
    return new Promise(function (resolve, reject) {
        glob(pattern, { ignore: ignore, cwd: cwd }, function (error, matches) {
            if (error) {
                reject(error);
            }
            else {
                resolve(matches);
            }
        });
    });
}
function findParentsWithNodeModules(dir) {
    return __awaiter(this, void 0, void 0, function () {
        var result, i, stats;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = [process.cwd()];
                    dir = path.resolve(dir);
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < 3)) return [3 /*break*/, 4];
                    dir = path.dirname(dir);
                    return [4 /*yield*/, statAsync(path.resolve(dir, 'node_modules'))];
                case 2:
                    stats = _a.sent();
                    if (stats && stats.isDirectory() && !result.includes(dir)) {
                        result.push(dir);
                    }
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/, result];
            }
        });
    });
}
