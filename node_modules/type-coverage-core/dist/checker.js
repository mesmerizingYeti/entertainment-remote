"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNode = void 0;
const tslib_1 = require("tslib");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
function collectAny(node, context, kind) {
    const { file, sourceFile, typeCheckResult, ingoreMap, ignoreUnreadAnys, debug, processAny } = context;
    if (processAny !== undefined) {
        return processAny(node, context);
    }
    const { line, character } = typescript_1.default.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));
    if (ingoreMap[file] && ingoreMap[file].has(line)) {
        return false;
    }
    if (ignoreUnreadAnys && isEvolvingAssignment(node)) {
        if (debug) {
            console.log(`Ignoring assignment to implicit any type: ${file}:${line + 1}:${character + 1}: ${node.parent.getText(sourceFile)}`);
        }
        return false;
    }
    if (debug) {
        console.log(`type === any(${kind}): ${file}:${line + 1}:${character + 1}: ${node.getText(sourceFile)}`);
    }
    else {
        typeCheckResult.anys.push({ line, character, text: node.getText(sourceFile), kind });
    }
    return true;
}
function collectNotAny(node, { file, sourceFile, typeCheckResult, debug }, type) {
    typeCheckResult.correctCount++;
    if (debug) {
        const { line, character } = typescript_1.default.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));
        console.log(`type !== any: ${file}:${line + 1}:${character + 1}: ${node.getText(sourceFile)} ${node.kind}(kind) ${type.flags}(flag) ${type.intrinsicName || ''}`);
    }
}
function collectData(node, context) {
    const types = [];
    const type = context.checker.getTypeAtLocation(node);
    if (type) {
        types.push(type);
    }
    const contextualType = context.checker.getContextualType(node);
    if (contextualType) {
        types.push(contextualType);
    }
    if (types.length > 0) {
        context.typeCheckResult.totalCount++;
        if (types.every((t) => typeIsStrictAny(t, context.strict))) {
            const kind = types.every((t) => typeIsStrictAny(t, false)) ? 1 /* any */ : 2 /* containsAny */;
            const success = collectAny(node, context, kind);
            if (!success) {
                collectNotAny(node, context, type);
            }
        }
        else {
            collectNotAny(node, context, type);
        }
    }
}
function typeIsStrictAny(type, strict) {
    if (type.flags === typescript_1.default.TypeFlags.Any) {
        return type.intrinsicName === 'any';
    }
    if (strict && type.flags === typescript_1.default.TypeFlags.Object) {
        const typeArguments = type.typeArguments;
        if (typeArguments) {
            return typeArguments.some((typeArgument) => typeIsStrictAny(typeArgument, strict));
        }
    }
    return false;
}
// See https://github.com/plantain-00/type-coverage/issues/28
function isEvolvingAssignment(node) {
    const { parent } = node;
    if (typescript_1.default.isVariableDeclaration(parent)) {
        // Match "let foo" and "let foo = null" but not "let foo: any".
        return !parent.type;
    }
    if (typescript_1.default.isBinaryExpression(parent)) {
        // Match "foo = 123".
        return parent.operatorToken.kind === typescript_1.default.SyntaxKind.EqualsToken;
    }
    return false;
}
function checkNodes(nodes, context) {
    if (nodes === undefined) {
        return;
    }
    for (const node of nodes) {
        checkNode(node, context);
    }
}
function checkTypeAssertion(node, context, kind) {
    if (context.strict) {
        // include `foo as any` and `<any>foo`
        if ((typescript_1.default.isAsExpression(node) || typescript_1.default.isTypeAssertion(node)) && node.type.kind !== typescript_1.default.SyntaxKind.AnyKeyword) {
            // exclude `foo as const` and `<const>foo`
            if (typescript_1.default.isTypeReferenceNode(node.type) && node.type.getText() === 'const') {
                return;
            }
            // exclude `foo as unknown` and `<unknown>foo`
            if (node.type.kind === typescript_1.default.SyntaxKind.UnknownKeyword) {
                return;
            }
            // exclude safe type assertion powered by isTypeAssignableTo
            const checker = context.checker;
            if (checker.isTypeAssignableTo
                && checker.isTypeAssignableTo(checker.getTypeAtLocation(node.expression), checker.getTypeFromTypeNode(node.type))) {
                return;
            }
        }
        const success = collectAny(node, context, kind);
        if (success) {
            context.typeCheckResult.totalCount++;
        }
    }
}
function checkNode(node, context) {
    if (node === undefined) {
        return;
    }
    if (context.debug) {
        const { line, character } = typescript_1.default.getLineAndCharacterOfPosition(context.sourceFile, node.getStart(context.sourceFile));
        console.log(`node: ${context.file}:${line + 1}:${character + 1}: ${node.getText(context.sourceFile)} ${node.kind}(kind)`);
    }
    checkNodes(node.decorators, context);
    checkNodes(node.modifiers, context);
    if (skippedNodeKinds.has(node.kind)) {
        return;
    }
    if (node.kind === typescript_1.default.SyntaxKind.ThisKeyword) {
        collectData(node, context);
        return;
    }
    if (typescript_1.default.isIdentifier(node)) {
        if (context.catchVariables[node.escapedText]) {
            return;
        }
        collectData(node, context);
        return;
    }
    if (typescript_1.default.isQualifiedName(node)) {
        checkNode(node.left, context);
        checkNode(node.right, context);
        return;
    }
    if (typescript_1.default.isComputedPropertyName(node)) {
        checkNode(node.expression, context);
        return;
    }
    if (typescript_1.default.isTypeParameterDeclaration(node)) {
        checkNode(node.name, context);
        checkNode(node.default, context);
        checkNode(node.expression, context);
        checkNode(node.constraint, context);
        return;
    }
    if (typescript_1.default.isParameter(node)) {
        checkNode(node.dotDotDotToken, context);
        checkNode(node.name, context);
        checkNode(node.initializer, context);
        checkNode(node.type, context);
        checkNode(node.questionToken, context);
        return;
    }
    if (typescript_1.default.isDecorator(node)) {
        checkNode(node.expression, context);
        return;
    }
    if (typescript_1.default.isPropertySignature(node)
        || typescript_1.default.isPropertyDeclaration(node)) {
        checkNode(node.name, context);
        checkNode(node.questionToken, context);
        checkNode(node.type, context);
        checkNode(node.initializer, context);
        return;
    }
    if (typescript_1.default.isMethodSignature(node)
        || typescript_1.default.isCallSignatureDeclaration(node)
        || typescript_1.default.isConstructSignatureDeclaration(node)
        || typescript_1.default.isIndexSignatureDeclaration(node)) {
        checkNode(node.name, context);
        checkNodes(node.parameters, context);
        checkNode(node.questionToken, context);
        checkNode(node.type, context);
        checkNodes(node.typeParameters, context);
        return;
    }
    if (typescript_1.default.isFunctionTypeNode(node)
        || typescript_1.default.isConstructorTypeNode(node)) {
        checkNode(node.name, context);
        checkNodes(node.parameters, context);
        checkNode(node.type, context);
        checkNodes(node.typeParameters, context);
        return;
    }
    if (typescript_1.default.isMethodDeclaration(node)
        || typescript_1.default.isConstructorDeclaration(node)
        || typescript_1.default.isGetAccessorDeclaration(node)
        || typescript_1.default.isSetAccessorDeclaration(node)
        || typescript_1.default.isFunctionExpression(node)
        || typescript_1.default.isArrowFunction(node)
        || typescript_1.default.isFunctionDeclaration(node)) {
        checkNode(node.name, context);
        checkNodes(node.parameters, context);
        checkNode(node.body, context);
        checkNode(node.asteriskToken, context);
        checkNode(node.questionToken, context);
        checkNode(node.type, context);
        checkNodes(node.typeParameters, context);
        return;
    }
    if (typescript_1.default.isTypePredicateNode(node)) {
        checkNode(node.type, context);
        checkNode(node.parameterName, context);
        return;
    }
    if (typescript_1.default.isTypeReferenceNode(node)) {
        checkNode(node.typeName, context);
        checkNodes(node.typeArguments, context);
        return;
    }
    if (typescript_1.default.isTypeQueryNode(node)) {
        checkNode(node.exprName, context);
        return;
    }
    if (typescript_1.default.isTypeLiteralNode(node)) {
        checkNodes(node.members, context);
        return;
    }
    if (typescript_1.default.isArrayTypeNode(node)) {
        checkNode(node.elementType, context);
        return;
    }
    if (typescript_1.default.isTupleTypeNode(node)) {
        checkNodes(node.elements, context);
        // for typescript < 4
        checkNodes(node.elementTypes, context);
        return;
    }
    if (typescript_1.default.isUnionTypeNode(node)
        || typescript_1.default.isIntersectionTypeNode(node)
        || typescript_1.default.isHeritageClause(node)) {
        checkNodes(node.types, context);
        return;
    }
    if (typescript_1.default.isConditionalTypeNode(node)) {
        checkNode(node.checkType, context);
        checkNode(node.extendsType, context);
        checkNode(node.trueType, context);
        checkNode(node.falseType, context);
        return;
    }
    if (typescript_1.default.isInferTypeNode(node)) {
        checkNode(node.typeParameter, context);
        return;
    }
    if (typescript_1.default.isParenthesizedTypeNode(node)
        || typescript_1.default.isTypeOperatorNode(node)) {
        checkNode(node.type, context);
        return;
    }
    if (typescript_1.default.isIndexedAccessTypeNode(node)) {
        checkNode(node.objectType, context);
        checkNode(node.indexType, context);
        return;
    }
    if (typescript_1.default.isMappedTypeNode(node)) {
        checkNode(node.questionToken, context);
        checkNode(node.readonlyToken, context);
        checkNode(node.type, context);
        checkNode(node.typeParameter, context);
        return;
    }
    if (typescript_1.default.isLiteralTypeNode(node)) {
        checkNode(node.literal, context);
        return;
    }
    if (typescript_1.default.isImportTypeNode(node)) {
        checkNode(node.qualifier, context);
        checkNode(node.argument, context);
        checkNodes(node.typeArguments, context);
        return;
    }
    if (typescript_1.default.isObjectBindingPattern(node)
        || typescript_1.default.isArrayBindingPattern(node)
        || typescript_1.default.isArrayLiteralExpression(node)
        || typescript_1.default.isNamedImports(node)
        || typescript_1.default.isNamedExports(node)) {
        checkNodes(node.elements, context);
        return;
    }
    if (typescript_1.default.isBindingElement(node)) {
        checkNode(node.name, context);
        checkNode(node.initializer, context);
        checkNode(node.dotDotDotToken, context);
        checkNode(node.propertyName, context);
        return;
    }
    if (typescript_1.default.isObjectLiteralExpression(node)
        || typescript_1.default.isJsxAttributes(node)) {
        checkNodes(node.properties, context);
        return;
    }
    if (typescript_1.default.isPropertyAccessExpression(node)
        || typescript_1.default.isExportAssignment(node)
        || typescript_1.default.isJsxSpreadAttribute(node)
        || typescript_1.default.isSpreadAssignment(node)) {
        checkNode(node.expression, context);
        checkNode(node.name, context);
        return;
    }
    if (typescript_1.default.isElementAccessExpression(node)) {
        checkNode(node.expression, context);
        checkNode(node.argumentExpression, context);
        return;
    }
    if (typescript_1.default.isCallExpression(node)
        || typescript_1.default.isNewExpression(node)) {
        checkNode(node.expression, context);
        checkNodes(node.arguments, context);
        checkNodes(node.typeArguments, context);
        return;
    }
    if (typescript_1.default.isTypeAssertion(node)) {
        checkTypeAssertion(node, context, 4 /* unsafeTypeAssertion */);
        checkNode(node.expression, context);
        checkNode(node.type, context);
        return;
    }
    if (typescript_1.default.isParenthesizedExpression(node)
        || typescript_1.default.isDeleteExpression(node)
        || typescript_1.default.isTypeOfExpression(node)
        || typescript_1.default.isVoidExpression(node)
        || typescript_1.default.isAwaitExpression(node)
        || typescript_1.default.isYieldExpression(node)
        || typescript_1.default.isSpreadElement(node)
        || typescript_1.default.isExpressionStatement(node)
        || typescript_1.default.isReturnStatement(node)
        || typescript_1.default.isThrowStatement(node)
        || typescript_1.default.isExternalModuleReference(node)) {
        checkNode(node.expression, context);
        return;
    }
    if (typescript_1.default.isTaggedTemplateExpression(node)) {
        checkNode(node.template, context);
        return;
    }
    if (typescript_1.default.isPrefixUnaryExpression(node)
        || typescript_1.default.isPostfixUnaryExpression(node)) {
        checkNode(node.operand, context);
        return;
    }
    if (typescript_1.default.isBinaryExpression(node)) {
        checkNode(node.left, context);
        checkNode(node.right, context);
        checkNode(node.operatorToken, context);
        return;
    }
    if (typescript_1.default.isConditionalExpression(node)) {
        checkNode(node.condition, context);
        checkNode(node.colonToken, context);
        checkNode(node.questionToken, context);
        checkNode(node.whenTrue, context);
        checkNode(node.whenFalse, context);
        return;
    }
    if (typescript_1.default.isTemplateExpression(node)) {
        checkNodes(node.templateSpans, context);
        return;
    }
    if (typescript_1.default.isClassExpression(node)
        || typescript_1.default.isClassDeclaration(node)
        || typescript_1.default.isInterfaceDeclaration(node)) {
        checkNode(node.name, context);
        checkNodes(node.typeParameters, context);
        checkNodes(node.members, context);
        checkNodes(node.heritageClauses, context);
        return;
    }
    if (typescript_1.default.isExpressionWithTypeArguments(node)) {
        checkNode(node.expression, context);
        checkNodes(node.typeArguments, context);
        return;
    }
    if (typescript_1.default.isAsExpression(node)) {
        checkTypeAssertion(node, context, 3 /* unsafeAs */);
        checkNode(node.expression, context);
        checkNode(node.type, context);
        return;
    }
    if (typescript_1.default.isNonNullExpression(node)) {
        checkTypeAssertion(node, context, 5 /* unsafeNonNull */);
        checkNode(node.expression, context);
        return;
    }
    if (typescript_1.default.isMetaProperty(node)
        || typescript_1.default.isSemicolonClassElement(node)
        || typescript_1.default.isNamespaceExportDeclaration(node)
        || typescript_1.default.isNamespaceImport(node)
        || typescript_1.default.isMissingDeclaration(node)) {
        checkNode(node.name, context);
        return;
    }
    if (typescript_1.default.isTemplateSpan(node)) {
        checkNode(node.expression, context);
        checkNode(node.literal, context);
        return;
    }
    if (typescript_1.default.isBlock(node)
        || typescript_1.default.isModuleBlock(node)
        || typescript_1.default.isDefaultClause(node)) {
        checkNodes(node.statements, context);
        return;
    }
    if (typescript_1.default.isVariableStatement(node)) {
        checkNode(node.declarationList, context);
        return;
    }
    if (typescript_1.default.isIfStatement(node)) {
        checkNode(node.expression, context);
        checkNode(node.thenStatement, context);
        checkNode(node.elseStatement, context);
        return;
    }
    if (typescript_1.default.isDoStatement(node)
        || typescript_1.default.isWhileStatement(node)
        || typescript_1.default.isWithStatement(node)) {
        checkNode(node.expression, context);
        checkNode(node.statement, context);
        return;
    }
    if (typescript_1.default.isForStatement(node)) {
        checkNode(node.initializer, context);
        checkNode(node.condition, context);
        checkNode(node.incrementor, context);
        checkNode(node.statement, context);
        return;
    }
    if (typescript_1.default.isForInStatement(node)) {
        checkNode(node.initializer, context);
        checkNode(node.expression, context);
        checkNode(node.statement, context);
        return;
    }
    if (typescript_1.default.isForOfStatement(node)) {
        checkNode(node.initializer, context);
        checkNode(node.statement, context);
        checkNode(node.expression, context);
        checkNode(node.awaitModifier, context);
        return;
    }
    if (typescript_1.default.isSwitchStatement(node)) {
        checkNode(node.expression, context);
        checkNode(node.caseBlock, context);
        return;
    }
    if (typescript_1.default.isLabeledStatement(node)) {
        checkNode(node.label, context);
        checkNode(node.statement, context);
        return;
    }
    if (typescript_1.default.isTryStatement(node)) {
        checkNode(node.tryBlock, context);
        checkNode(node.catchClause, context);
        checkNode(node.finallyBlock, context);
        return;
    }
    if (typescript_1.default.isVariableDeclaration(node)) {
        checkNode(node.name, context);
        checkNode(node.type, context);
        checkNode(node.initializer, context);
        return;
    }
    if (typescript_1.default.isVariableDeclarationList(node)) {
        checkNodes(node.declarations, context);
        return;
    }
    if (typescript_1.default.isTypeAliasDeclaration(node)) {
        checkNode(node.name, context);
        checkNode(node.type, context);
        checkNodes(node.typeParameters, context);
        return;
    }
    if (typescript_1.default.isEnumDeclaration(node)) {
        checkNode(node.name, context);
        checkNodes(node.members, context);
        return;
    }
    if (typescript_1.default.isModuleDeclaration(node)) {
        checkNode(node.name, context);
        checkNode(node.body, context);
        return;
    }
    if (typescript_1.default.isCaseBlock(node)) {
        checkNodes(node.clauses, context);
        return;
    }
    if (typescript_1.default.isImportEqualsDeclaration(node)) {
        checkNode(node.name, context);
        checkNode(node.moduleReference, context);
        return;
    }
    if (typescript_1.default.isImportDeclaration(node)) {
        checkNode(node.importClause, context);
        checkNode(node.moduleSpecifier, context);
        return;
    }
    if (typescript_1.default.isImportClause(node)) {
        checkNode(node.name, context);
        checkNode(node.namedBindings, context);
        return;
    }
    if (typescript_1.default.isImportSpecifier(node)
        || typescript_1.default.isExportSpecifier(node)) {
        checkNode(node.name, context);
        checkNode(node.propertyName, context);
        return;
    }
    if (typescript_1.default.isExportDeclaration(node)) {
        checkNode(node.exportClause, context);
        checkNode(node.name, context);
        checkNode(node.moduleSpecifier, context);
        return;
    }
    if (typescript_1.default.isJsxElement(node)) {
        checkNode(node.openingElement, context);
        checkNode(node.closingElement, context);
        checkNodes(node.children, context);
        return;
    }
    if (typescript_1.default.isJsxSelfClosingElement(node)
        || typescript_1.default.isJsxOpeningElement(node)) {
        checkNode(node.attributes, context);
        checkNode(node.tagName, context);
        return;
    }
    if (typescript_1.default.isJsxClosingElement(node)) {
        checkNode(node.tagName, context);
        return;
    }
    if (typescript_1.default.isJsxFragment(node)) {
        checkNode(node.openingFragment, context);
        checkNode(node.closingFragment, context);
        checkNodes(node.children, context);
        return;
    }
    if (typescript_1.default.isJsxAttribute(node)) {
        checkNode(node.name, context);
        checkNode(node.initializer, context);
        return;
    }
    if (typescript_1.default.isJsxExpression(node)) {
        checkNode(node.dotDotDotToken, context);
        checkNode(node.expression, context);
        return;
    }
    if (typescript_1.default.isCaseClause(node)) {
        checkNodes(node.statements, context);
        checkNode(node.expression, context);
        return;
    }
    if (typescript_1.default.isCatchClause(node)) {
        if (context.ignoreCatch) {
            const copyContext = Object.assign({}, context);
            copyContext.catchVariables = Object.assign({}, context.catchVariables);
            if (node.variableDeclaration) {
                const decl = node.variableDeclaration;
                if (decl.name.kind === typescript_1.default.SyntaxKind.Identifier) {
                    copyContext.catchVariables[decl.name.escapedText] = true;
                }
            }
            checkNode(node.variableDeclaration, copyContext);
        }
        else {
            checkNode(node.block, context);
            checkNode(node.variableDeclaration, context);
        }
        return;
    }
    if (typescript_1.default.isPropertyAssignment(node)) {
        checkNode(node.name, context);
        checkNode(node.questionToken, context);
        checkNode(node.initializer, context);
        return;
    }
    if (typescript_1.default.isShorthandPropertyAssignment(node)) {
        checkNode(node.name, context);
        checkNode(node.questionToken, context);
        checkNode(node.equalsToken, context);
        checkNode(node.objectAssignmentInitializer, context);
        return;
    }
    if (node.kind === typescript_1.default.SyntaxKind.RestType) {
        checkNode(node.type, context);
        return;
    }
    if (typescript_1.default.isNamedTupleMember(node)) {
        checkNode(node.name, context);
        checkNode(node.type, context);
        return;
    }
    if (typescript_1.default.isTemplateLiteralTypeNode(node)) {
        checkNode(node.head, context);
        checkNodes(node.templateSpans, context);
        return;
    }
    if (typescript_1.default.isTemplateLiteralTypeSpan(node)) {
        checkNode(node.literal, context);
        checkNode(node.type, context);
        return;
    }
    if (typescript_1.default.isNamespaceExport(node)) {
        checkNode(node.name, context);
        return;
    }
    console.log(`warning: unhandled node kind: ${node.kind}`);
}
exports.checkNode = checkNode;
const skippedNodeKinds = new Set([
    typescript_1.default.SyntaxKind.Unknown,
    typescript_1.default.SyntaxKind.EndOfFileToken,
    typescript_1.default.SyntaxKind.SingleLineCommentTrivia,
    typescript_1.default.SyntaxKind.MultiLineCommentTrivia,
    typescript_1.default.SyntaxKind.NewLineTrivia,
    typescript_1.default.SyntaxKind.WhitespaceTrivia,
    typescript_1.default.SyntaxKind.ShebangTrivia,
    typescript_1.default.SyntaxKind.ConflictMarkerTrivia,
    typescript_1.default.SyntaxKind.NumericLiteral,
    typescript_1.default.SyntaxKind.StringLiteral,
    typescript_1.default.SyntaxKind.JsxText,
    typescript_1.default.SyntaxKind.JsxTextAllWhiteSpaces,
    typescript_1.default.SyntaxKind.RegularExpressionLiteral,
    typescript_1.default.SyntaxKind.NoSubstitutionTemplateLiteral,
    typescript_1.default.SyntaxKind.TemplateHead,
    typescript_1.default.SyntaxKind.TemplateMiddle,
    typescript_1.default.SyntaxKind.TemplateTail,
    typescript_1.default.SyntaxKind.OpenBraceToken,
    typescript_1.default.SyntaxKind.CloseBraceToken,
    typescript_1.default.SyntaxKind.OpenParenToken,
    typescript_1.default.SyntaxKind.CloseParenToken,
    typescript_1.default.SyntaxKind.OpenBracketToken,
    typescript_1.default.SyntaxKind.CloseBracketToken,
    typescript_1.default.SyntaxKind.DotToken,
    typescript_1.default.SyntaxKind.DotDotDotToken,
    typescript_1.default.SyntaxKind.SemicolonToken,
    typescript_1.default.SyntaxKind.CommaToken,
    typescript_1.default.SyntaxKind.LessThanToken,
    typescript_1.default.SyntaxKind.LessThanSlashToken,
    typescript_1.default.SyntaxKind.GreaterThanToken,
    typescript_1.default.SyntaxKind.LessThanEqualsToken,
    typescript_1.default.SyntaxKind.GreaterThanEqualsToken,
    typescript_1.default.SyntaxKind.EqualsEqualsToken,
    typescript_1.default.SyntaxKind.ExclamationEqualsToken,
    typescript_1.default.SyntaxKind.EqualsEqualsEqualsToken,
    typescript_1.default.SyntaxKind.ExclamationEqualsEqualsToken,
    typescript_1.default.SyntaxKind.EqualsGreaterThanToken,
    typescript_1.default.SyntaxKind.PlusToken,
    typescript_1.default.SyntaxKind.MinusToken,
    typescript_1.default.SyntaxKind.AsteriskToken,
    typescript_1.default.SyntaxKind.AsteriskAsteriskToken,
    typescript_1.default.SyntaxKind.SlashToken,
    typescript_1.default.SyntaxKind.PercentToken,
    typescript_1.default.SyntaxKind.PlusPlusToken,
    typescript_1.default.SyntaxKind.MinusMinusToken,
    typescript_1.default.SyntaxKind.LessThanLessThanToken,
    typescript_1.default.SyntaxKind.GreaterThanGreaterThanToken,
    typescript_1.default.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
    typescript_1.default.SyntaxKind.AmpersandToken,
    typescript_1.default.SyntaxKind.BarToken,
    typescript_1.default.SyntaxKind.CaretToken,
    typescript_1.default.SyntaxKind.ExclamationToken,
    typescript_1.default.SyntaxKind.TildeToken,
    typescript_1.default.SyntaxKind.AmpersandAmpersandToken,
    typescript_1.default.SyntaxKind.BarBarToken,
    typescript_1.default.SyntaxKind.QuestionToken,
    typescript_1.default.SyntaxKind.ColonToken,
    typescript_1.default.SyntaxKind.AtToken,
    typescript_1.default.SyntaxKind.QuestionQuestionToken,
    typescript_1.default.SyntaxKind.EqualsToken,
    typescript_1.default.SyntaxKind.PlusEqualsToken,
    typescript_1.default.SyntaxKind.MinusEqualsToken,
    typescript_1.default.SyntaxKind.AsteriskEqualsToken,
    typescript_1.default.SyntaxKind.AsteriskAsteriskEqualsToken,
    typescript_1.default.SyntaxKind.SlashEqualsToken,
    typescript_1.default.SyntaxKind.PercentEqualsToken,
    typescript_1.default.SyntaxKind.LessThanLessThanEqualsToken,
    typescript_1.default.SyntaxKind.GreaterThanGreaterThanEqualsToken,
    typescript_1.default.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
    typescript_1.default.SyntaxKind.AmpersandEqualsToken,
    typescript_1.default.SyntaxKind.BarEqualsToken,
    typescript_1.default.SyntaxKind.CaretEqualsToken,
    typescript_1.default.SyntaxKind.BreakKeyword,
    typescript_1.default.SyntaxKind.CaseKeyword,
    typescript_1.default.SyntaxKind.CatchKeyword,
    typescript_1.default.SyntaxKind.ClassKeyword,
    typescript_1.default.SyntaxKind.ConstKeyword,
    typescript_1.default.SyntaxKind.ContinueKeyword,
    typescript_1.default.SyntaxKind.DebuggerKeyword,
    typescript_1.default.SyntaxKind.DefaultKeyword,
    typescript_1.default.SyntaxKind.DeleteKeyword,
    typescript_1.default.SyntaxKind.DoKeyword,
    typescript_1.default.SyntaxKind.ElseKeyword,
    typescript_1.default.SyntaxKind.EnumKeyword,
    typescript_1.default.SyntaxKind.ExportKeyword,
    typescript_1.default.SyntaxKind.ExtendsKeyword,
    typescript_1.default.SyntaxKind.FalseKeyword,
    typescript_1.default.SyntaxKind.FinallyKeyword,
    typescript_1.default.SyntaxKind.ForKeyword,
    typescript_1.default.SyntaxKind.FunctionKeyword,
    typescript_1.default.SyntaxKind.IfKeyword,
    typescript_1.default.SyntaxKind.ImportKeyword,
    typescript_1.default.SyntaxKind.InKeyword,
    typescript_1.default.SyntaxKind.InstanceOfKeyword,
    typescript_1.default.SyntaxKind.NewKeyword,
    typescript_1.default.SyntaxKind.NullKeyword,
    typescript_1.default.SyntaxKind.ReturnKeyword,
    typescript_1.default.SyntaxKind.SuperKeyword,
    typescript_1.default.SyntaxKind.SwitchKeyword,
    typescript_1.default.SyntaxKind.ThrowKeyword,
    typescript_1.default.SyntaxKind.TrueKeyword,
    typescript_1.default.SyntaxKind.TryKeyword,
    typescript_1.default.SyntaxKind.TypeOfKeyword,
    typescript_1.default.SyntaxKind.VarKeyword,
    typescript_1.default.SyntaxKind.VoidKeyword,
    typescript_1.default.SyntaxKind.WhileKeyword,
    typescript_1.default.SyntaxKind.WithKeyword,
    typescript_1.default.SyntaxKind.ImplementsKeyword,
    typescript_1.default.SyntaxKind.InterfaceKeyword,
    typescript_1.default.SyntaxKind.LetKeyword,
    typescript_1.default.SyntaxKind.PackageKeyword,
    typescript_1.default.SyntaxKind.PrivateKeyword,
    typescript_1.default.SyntaxKind.ProtectedKeyword,
    typescript_1.default.SyntaxKind.PublicKeyword,
    typescript_1.default.SyntaxKind.StaticKeyword,
    typescript_1.default.SyntaxKind.YieldKeyword,
    typescript_1.default.SyntaxKind.AbstractKeyword,
    typescript_1.default.SyntaxKind.AsKeyword,
    typescript_1.default.SyntaxKind.AnyKeyword,
    typescript_1.default.SyntaxKind.AsyncKeyword,
    typescript_1.default.SyntaxKind.AwaitKeyword,
    typescript_1.default.SyntaxKind.BooleanKeyword,
    typescript_1.default.SyntaxKind.ConstructorKeyword,
    typescript_1.default.SyntaxKind.DeclareKeyword,
    typescript_1.default.SyntaxKind.GetKeyword,
    typescript_1.default.SyntaxKind.IsKeyword,
    typescript_1.default.SyntaxKind.KeyOfKeyword,
    typescript_1.default.SyntaxKind.ModuleKeyword,
    typescript_1.default.SyntaxKind.NamespaceKeyword,
    typescript_1.default.SyntaxKind.NeverKeyword,
    typescript_1.default.SyntaxKind.ReadonlyKeyword,
    typescript_1.default.SyntaxKind.RequireKeyword,
    typescript_1.default.SyntaxKind.NumberKeyword,
    typescript_1.default.SyntaxKind.ObjectKeyword,
    typescript_1.default.SyntaxKind.SetKeyword,
    typescript_1.default.SyntaxKind.StringKeyword,
    typescript_1.default.SyntaxKind.SymbolKeyword,
    typescript_1.default.SyntaxKind.TypeKeyword,
    typescript_1.default.SyntaxKind.UndefinedKeyword,
    typescript_1.default.SyntaxKind.UniqueKeyword,
    typescript_1.default.SyntaxKind.UnknownKeyword,
    typescript_1.default.SyntaxKind.FromKeyword,
    typescript_1.default.SyntaxKind.GlobalKeyword,
    typescript_1.default.SyntaxKind.BigIntKeyword,
    typescript_1.default.SyntaxKind.OfKeyword,
    typescript_1.default.SyntaxKind.OptionalType,
    typescript_1.default.SyntaxKind.ThisType,
    typescript_1.default.SyntaxKind.OmittedExpression,
    typescript_1.default.SyntaxKind.EmptyStatement,
    typescript_1.default.SyntaxKind.ContinueStatement,
    typescript_1.default.SyntaxKind.BreakStatement,
    typescript_1.default.SyntaxKind.DebuggerStatement,
    typescript_1.default.SyntaxKind.JsxOpeningFragment,
    typescript_1.default.SyntaxKind.JsxClosingFragment,
    typescript_1.default.SyntaxKind.EnumMember,
    typescript_1.default.SyntaxKind.SourceFile,
    typescript_1.default.SyntaxKind.Bundle,
    typescript_1.default.SyntaxKind.JSDocTypeExpression,
    typescript_1.default.SyntaxKind.JSDocAllType,
    typescript_1.default.SyntaxKind.JSDocUnknownType,
    typescript_1.default.SyntaxKind.JSDocNullableType,
    typescript_1.default.SyntaxKind.JSDocNonNullableType,
    typescript_1.default.SyntaxKind.JSDocOptionalType,
    typescript_1.default.SyntaxKind.JSDocFunctionType,
    typescript_1.default.SyntaxKind.JSDocVariadicType,
    typescript_1.default.SyntaxKind.JSDocComment,
    typescript_1.default.SyntaxKind.JSDocTag,
    typescript_1.default.SyntaxKind.JSDocAugmentsTag,
    typescript_1.default.SyntaxKind.JSDocClassTag,
    typescript_1.default.SyntaxKind.JSDocParameterTag,
    typescript_1.default.SyntaxKind.JSDocReturnTag,
    typescript_1.default.SyntaxKind.JSDocTypeTag,
    typescript_1.default.SyntaxKind.JSDocTemplateTag,
    typescript_1.default.SyntaxKind.JSDocTypedefTag,
    typescript_1.default.SyntaxKind.JSDocPropertyTag,
    typescript_1.default.SyntaxKind.JSDocTypeLiteral,
    typescript_1.default.SyntaxKind.SyntaxList,
    typescript_1.default.SyntaxKind.NotEmittedStatement,
    typescript_1.default.SyntaxKind.PartiallyEmittedExpression,
    typescript_1.default.SyntaxKind.CommaListExpression,
    typescript_1.default.SyntaxKind.MergeDeclarationMarker,
    typescript_1.default.SyntaxKind.EndOfDeclarationMarker,
    typescript_1.default.SyntaxKind.Count,
]);
